name: üöÄ X-Fleet CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  IMAGE_NAME: x-fleet
  CONTAINER_NAME: x-fleet-app
  DB_CONTAINER_NAME: x-fleet-postgres
  NETWORK_NAME: x-fleet-network

jobs:
  # Build and Test Job
  build:
    name: üèóÔ∏è Build & Test
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üè∑Ô∏è Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: üî® Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: üß™ Test Docker Image
        if: github.event_name != 'pull_request'
        run: |
          echo "Testing built image..."
          docker run --rm --entrypoint="" ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest node --version
          docker run --rm --entrypoint="" ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest ls -la /app/dist

  # Deploy Job (only on main branch)
  deploy:
    name: üöÄ Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üìù Create Deployment Files
        run: |
          # Create deployment directory
          mkdir -p deploy
          
          # Create docker-compose.prod.yml for deployment using echo to avoid heredoc issues
          echo "services:" > deploy/docker-compose.prod.yml
          echo "  x-fleet-app:" >> deploy/docker-compose.prod.yml
          echo "    image: ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest" >> deploy/docker-compose.prod.yml
          echo "    container_name: x-fleet-app" >> deploy/docker-compose.prod.yml
          echo "    restart: unless-stopped" >> deploy/docker-compose.prod.yml
          echo "    ports:" >> deploy/docker-compose.prod.yml
          echo "      - \"3001:3001\"" >> deploy/docker-compose.prod.yml
          echo "      - \"80:3001\"" >> deploy/docker-compose.prod.yml
          echo "    env_file:" >> deploy/docker-compose.prod.yml
          echo "      - .env" >> deploy/docker-compose.prod.yml
          echo "    depends_on:" >> deploy/docker-compose.prod.yml
          echo "      - x-fleet-postgres" >> deploy/docker-compose.prod.yml
          echo "    networks:" >> deploy/docker-compose.prod.yml
          echo "      - xfleet" >> deploy/docker-compose.prod.yml
          echo "    healthcheck:" >> deploy/docker-compose.prod.yml
          echo "      test: [\"CMD\", \"sh\", \"-c\", \"node --version || exit 1\"]" >> deploy/docker-compose.prod.yml
          echo "      interval: 30s" >> deploy/docker-compose.prod.yml
          echo "      timeout: 10s" >> deploy/docker-compose.prod.yml
          echo "      retries: 3" >> deploy/docker-compose.prod.yml
          echo "      start_period: 30s" >> deploy/docker-compose.prod.yml
          echo "" >> deploy/docker-compose.prod.yml
          echo "  x-fleet-postgres:" >> deploy/docker-compose.prod.yml
          echo "    image: postgres:15-alpine" >> deploy/docker-compose.prod.yml
          echo "    container_name: x-fleet-postgres" >> deploy/docker-compose.prod.yml
          echo "    restart: unless-stopped" >> deploy/docker-compose.prod.yml
          echo "    ports:" >> deploy/docker-compose.prod.yml
          echo "      - \"5432:5432\"" >> deploy/docker-compose.prod.yml
          echo "    env_file:" >> deploy/docker-compose.prod.yml
          echo "      - .env" >> deploy/docker-compose.prod.yml
          echo "    volumes:" >> deploy/docker-compose.prod.yml
          echo "      - postgres_data:/var/lib/postgresql/data" >> deploy/docker-compose.prod.yml
          echo "      - ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql" >> deploy/docker-compose.prod.yml
          echo "    networks:" >> deploy/docker-compose.prod.yml
          echo "      - xfleet" >> deploy/docker-compose.prod.yml
          echo "    healthcheck:" >> deploy/docker-compose.prod.yml
          echo "      test: [\"CMD-SHELL\", \"pg_isready -U \$\$POSTGRES_USER\"]" >> deploy/docker-compose.prod.yml
          echo "      interval: 10s" >> deploy/docker-compose.prod.yml
          echo "      timeout: 5s" >> deploy/docker-compose.prod.yml
          echo "      retries: 5" >> deploy/docker-compose.prod.yml
          echo "" >> deploy/docker-compose.prod.yml
          echo "networks:" >> deploy/docker-compose.prod.yml
          echo "  xfleet:" >> deploy/docker-compose.prod.yml
          echo "    driver: bridge" >> deploy/docker-compose.prod.yml
          echo "" >> deploy/docker-compose.prod.yml
          echo "volumes:" >> deploy/docker-compose.prod.yml
          echo "  postgres_data:" >> deploy/docker-compose.prod.yml
          
          # Create database initialization script
          cat > deploy/init-db.sql << 'EOF'
          -- Create multiple databases for the application
          CREATE DATABASE "FleetStack_db";
          CREATE DATABASE "FleetStack_logs";  
          CREATE DATABASE "FleetStack_Address";

          -- Grant privileges
          GRANT ALL PRIVILEGES ON DATABASE "FleetStack_db" TO postgres;
          GRANT ALL PRIVILEGES ON DATABASE "FleetStack_logs" TO postgres;
          GRANT ALL PRIVILEGES ON DATABASE "FleetStack_Address" TO postgres;
          EOF
          
          # Create deployment script
          cat > deploy/deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "üöÄ Starting X-Fleet deployment..."

          # Variables
          COMPOSE_FILE="docker-compose.prod.yml"
          APP_CONTAINER="x-fleet-app"
          DB_CONTAINER="x-fleet-postgres"
          BACKUP_CONTAINER="x-fleet-app-backup"

          # Set docker compose command based on availability
          if command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1; then
            DOCKER_COMPOSE_CMD="docker compose"
          elif command -v docker-compose &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker-compose"
          else
            echo "‚ùå Neither 'docker compose' nor 'docker-compose' found"
            exit 1
          fi
          
          echo "üìã Using: $DOCKER_COMPOSE_CMD"
          
          # Debug: Show compose file content
          echo "üîç Debugging: Docker Compose file content:"
          cat $COMPOSE_FILE
          echo "=== End of compose file ==="
          
          # Validate compose file
          echo "üîç Validating Docker Compose file..."
          $DOCKER_COMPOSE_CMD -f $COMPOSE_FILE config
          
          # Function to check container health
          check_health() {
            local container_name=$1
            local max_attempts=30
            local attempt=1
            
            echo "‚è≥ Checking health of $container_name..."
            
            while [ $attempt -le $max_attempts ]; do
              if [ "$(docker inspect --format='{{.State.Health.Status}}' $container_name 2>/dev/null)" = "healthy" ]; then
                echo "‚úÖ $container_name is healthy"
                return 0
              fi
              
              echo "üîÑ Attempt $attempt/$max_attempts: Waiting for $container_name to be healthy..."
              sleep 10
              ((attempt++))
            done
            
            echo "‚ùå $container_name failed health check"
            return 1
          }

          # Function to rollback
          rollback() {
            echo "üîÑ Rolling back to previous version..."
            
            if docker ps -a | grep -q $BACKUP_CONTAINER; then
              echo "üì¶ Stopping current container..."
              docker stop $APP_CONTAINER || true
              docker rm $APP_CONTAINER || true
              
              echo "üîÑ Starting backup container..."
              docker start $BACKUP_CONTAINER
              docker rename $BACKUP_CONTAINER $APP_CONTAINER
              
              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup container found for rollback"
              exit 1
            fi
          }

          # Create backup of current container if exists
          if docker ps | grep -q $APP_CONTAINER; then
            echo "üì¶ Creating backup of current container..."
            docker stop $APP_CONTAINER
            docker rename $APP_CONTAINER $BACKUP_CONTAINER
          fi

          # Pull latest images
          echo "üì• Pulling latest images..."
          docker pull ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          docker pull postgres:15-alpine

          # Start database first (if not already running)
          if ! docker ps | grep -q $DB_CONTAINER; then
            echo "üóÑÔ∏è Starting database container..."
            $DOCKER_COMPOSE_CMD -f $COMPOSE_FILE up -d x-fleet-postgres
            
            # Wait for database to be healthy
            if ! check_health $DB_CONTAINER; then
              echo "‚ùå Database health check failed"
              exit 1
            fi
          fi

          # Start application container
          echo "üöÄ Starting application container..."
          $DOCKER_COMPOSE_CMD -f $COMPOSE_FILE up -d x-fleet-app

          # Check if deployment was successful
          if check_health $APP_CONTAINER; then
            echo "‚úÖ Deployment successful!"
            
            # Remove backup container if deployment succeeded
            if docker ps -a | grep -q $BACKUP_CONTAINER; then
              echo "üßπ Removing backup container..."
              docker rm $BACKUP_CONTAINER || true
            fi
            
            # Clean up unused images
            docker image prune -f
            
            echo "üéâ X-Fleet deployment completed successfully!"
          else
            echo "‚ùå Deployment failed!"
            rollback
            exit 1
          fi
          EOF

          chmod +x deploy/deploy.sh
          
          # Debug: Show generated files
          echo "=== Generated docker-compose.prod.yml ==="
          cat deploy/docker-compose.prod.yml
          echo "=== End of docker-compose.prod.yml ==="

      - name: üì§ Deploy to EC2 Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          timeout: 300s
          command_timeout: 60s
          script: |
            # Create deployment directory
            mkdir -p ~/x-fleet-deployment
            cd ~/x-fleet-deployment
            
            # Install Docker if not present
            if ! command -v docker &> /dev/null; then
              echo "üê≥ Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              newgrp docker
            fi
            
            # Install Docker Compose if not present
            if ! docker compose version &> /dev/null && ! docker-compose version &> /dev/null; then
              echo "üêô Installing Docker Compose..."
              sudo apt-get update
              sudo apt-get install -y docker-compose-plugin
              
              # Fallback: install standalone docker-compose if plugin fails
              if ! docker compose version &> /dev/null; then
                echo "üîÑ Installing standalone docker-compose..."
                sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                sudo chmod +x /usr/local/bin/docker-compose
              fi
            else
              echo "‚úÖ Docker Compose already installed"
              docker compose version 2>/dev/null || docker-compose version
            fi
            
            # Login to Docker registry
            echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ secrets.REGISTRY_URL }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
            
            echo "üöÄ Starting deployment process..."

      - name: üìÅ Copy Deployment Files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          source: "deploy/*"
          target: "~/x-fleet-deployment/"
          strip_components: 1

      - name: üöÄ Execute Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          timeout: 600s
          script: |
            cd ~/x-fleet-deployment
            
            # Check if .env file exists, create if not
            if [ ! -f .env ]; then
              echo "üìù Creating .env file from environment variables..."
              cat > .env << 'EOF'
            # Environment Configuration for FleetStack Backend
            NODE_ENV=production
            PORT=3001

            # Database Configuration
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=Stack@321
            POSTGRES_DB=postgres

            # Primary Database Configuration (FleetStack_db)
            PRIMARY_DB_HOST=x-fleet-postgres
            PRIMARY_DB_USER=postgres
            PRIMARY_DB_PORT=5432
            PRIMARY_DB_PASSWORD=Stack@321
            PRIMARY_DB_NAME=FleetStack_db
            PRIMARY_DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_db?schema=public"

            # Logs Database Configuration (FleetStack_logs)
            LOGS_DB_HOST=x-fleet-postgres
            LOGS_DB_USER=postgres
            LOGS_DB_PORT=5432
            LOGS_DB_PASSWORD=Stack@321
            LOGS_DB_NAME=FleetStack_logs
            LOGS_DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_logs?schema=public"

            # Address Database Configuration (FleetStack_Address)
            ADDRESS_DB_HOST=x-fleet-postgres
            ADDRESS_DB_USER=postgres
            ADDRESS_DB_PORT=5432
            ADDRESS_DB_PASSWORD=Stack@321
            ADDRESS_DB_NAME=FleetStack_Address
            ADDRESS_DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_Address?schema=public"

            # Default DATABASE_URL for Prisma
            DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_db?schema=public"
            EOF
            fi
            
            # Make deployment script executable and run it
            chmod +x deploy.sh
            ./deploy.sh

  # Notification Job
  notify:
    name: üì¢ Notify
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: üìä Deployment Status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Deployment succeeded!"
            echo "üåç Application URL: http://${{ secrets.EC2_HOST }}:3001"
            echo "üåê Alternative URL: http://${{ secrets.EC2_HOST }}:80"
            echo "üóÑÔ∏è Database URL: ${{ secrets.EC2_HOST }}:5432"
          elif [[ "${{ needs.deploy.result }}" == "failure" ]]; then
            echo "‚ùå Deployment failed!"
            exit 1
          elif [[ "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "‚è≠Ô∏è Deployment skipped (not main branch)"
          fi
