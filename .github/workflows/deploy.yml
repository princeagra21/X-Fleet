name: ðŸš€ X-Fleet CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  IMAGE_NAME: x-fleet
  CONTAINER_NAME: x-fleet-app
  DB_CONTAINER_NAME: x-fleet-postgres
  NETWORK_NAME: x-fleet-network

jobs:
  # Build and Test Job
  build:
    name: ðŸ—ï¸ Build & Test
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ·ï¸ Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: ðŸ”¨ Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: ðŸ§ª Test Docker Image
        if: github.event_name != 'pull_request'
        run: |
          echo "Testing built image..."
          docker run --rm --entrypoint="" ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest node --version
          docker run --rm --entrypoint="" ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest ls -la /app/dist

  # Deploy Job (only on main branch)
  deploy:
    name: ðŸš€ Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ“ Create Deployment Files
        run: |
          # Create deployment directory
          mkdir -p deploy
          
          # Create docker-compose.prod.yml for deployment using echo to avoid heredoc issues
          echo "services:" > deploy/docker-compose.prod.yml
          echo "  x-fleet-app:" >> deploy/docker-compose.prod.yml
          echo "    image: ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest" >> deploy/docker-compose.prod.yml
          echo "    container_name: x-fleet-app" >> deploy/docker-compose.prod.yml
          echo "    restart: unless-stopped" >> deploy/docker-compose.prod.yml
          echo "    ports:" >> deploy/docker-compose.prod.yml
          echo "      - \"3001:3001\"" >> deploy/docker-compose.prod.yml
          echo "    env_file:" >> deploy/docker-compose.prod.yml
          echo "      - .env" >> deploy/docker-compose.prod.yml
          echo "    depends_on:" >> deploy/docker-compose.prod.yml
          echo "      - x-fleet-postgres" >> deploy/docker-compose.prod.yml
          echo "    networks:" >> deploy/docker-compose.prod.yml
          echo "      - xfleet" >> deploy/docker-compose.prod.yml
          echo "    healthcheck:" >> deploy/docker-compose.prod.yml
          echo "      test: [\"CMD\", \"sh\", \"-c\", \"node --version || exit 1\"]" >> deploy/docker-compose.prod.yml
          echo "      interval: 30s" >> deploy/docker-compose.prod.yml
          echo "      timeout: 10s" >> deploy/docker-compose.prod.yml
          echo "      retries: 3" >> deploy/docker-compose.prod.yml
          echo "      start_period: 30s" >> deploy/docker-compose.prod.yml
          echo "" >> deploy/docker-compose.prod.yml
          echo "  x-fleet-postgres:" >> deploy/docker-compose.prod.yml
          echo "    image: postgres:15-alpine" >> deploy/docker-compose.prod.yml
          echo "    container_name: x-fleet-postgres" >> deploy/docker-compose.prod.yml
          echo "    restart: unless-stopped" >> deploy/docker-compose.prod.yml
          echo "    ports:" >> deploy/docker-compose.prod.yml
          echo "      - \"5432:5432\"" >> deploy/docker-compose.prod.yml
          echo "    env_file:" >> deploy/docker-compose.prod.yml
          echo "      - .env" >> deploy/docker-compose.prod.yml
          echo "    volumes:" >> deploy/docker-compose.prod.yml
          echo "      - postgres_data:/var/lib/postgresql/data" >> deploy/docker-compose.prod.yml
          echo "      - ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql" >> deploy/docker-compose.prod.yml
          echo "    networks:" >> deploy/docker-compose.prod.yml
          echo "      - xfleet" >> deploy/docker-compose.prod.yml
          echo "    healthcheck:" >> deploy/docker-compose.prod.yml
          echo "      test: [\"CMD-SHELL\", \"pg_isready -U \$\$POSTGRES_USER\"]" >> deploy/docker-compose.prod.yml
          echo "      interval: 10s" >> deploy/docker-compose.prod.yml
          echo "      timeout: 5s" >> deploy/docker-compose.prod.yml
          echo "      retries: 5" >> deploy/docker-compose.prod.yml
          echo "" >> deploy/docker-compose.prod.yml
          echo "networks:" >> deploy/docker-compose.prod.yml
          echo "  xfleet:" >> deploy/docker-compose.prod.yml
          echo "    driver: bridge" >> deploy/docker-compose.prod.yml
          echo "" >> deploy/docker-compose.prod.yml
          echo "volumes:" >> deploy/docker-compose.prod.yml
          echo "  postgres_data:" >> deploy/docker-compose.prod.yml
          
          # Create database initialization script
          cat > deploy/init-db.sql << 'EOF'
          -- Create multiple databases for the application
          CREATE DATABASE "FleetStack_db";
          CREATE DATABASE "FleetStack_logs";  
          CREATE DATABASE "FleetStack_Address";

          -- Grant privileges
          GRANT ALL PRIVILEGES ON DATABASE "FleetStack_db" TO postgres;
          GRANT ALL PRIVILEGES ON DATABASE "FleetStack_logs" TO postgres;
          GRANT ALL PRIVILEGES ON DATABASE "FleetStack_Address" TO postgres;
          EOF
          
          # Create deployment script
          cat > deploy/deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "ðŸš€ Starting X-Fleet deployment..."

          # Variables
          COMPOSE_FILE="docker-compose.prod.yml"
          APP_CONTAINER="x-fleet-app"
          DB_CONTAINER="x-fleet-postgres"
          BACKUP_CONTAINER="x-fleet-app-backup"

          # Set docker compose command based on availability
          if command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1; then
            DOCKER_COMPOSE_CMD="docker compose"
          elif command -v docker-compose &> /dev/null; then
            DOCKER_COMPOSE_CMD="docker-compose"
          else
            echo "âŒ Neither 'docker compose' nor 'docker-compose' found"
            exit 1
          fi
          
          echo "ðŸ“‹ Using: $DOCKER_COMPOSE_CMD"
          
          # Debug: Show compose file content
          echo "ðŸ” Debugging: Docker Compose file content:"
          cat $COMPOSE_FILE
          echo "=== End of compose file ==="
          
          # Validate compose file
          echo "ðŸ” Validating Docker Compose file..."
          $DOCKER_COMPOSE_CMD -f $COMPOSE_FILE config
          
          # Function to check container health
          check_health() {
            local container_name=$1
            local max_attempts=30
            local attempt=1
            
            echo "â³ Checking health of $container_name..."
            
            while [ $attempt -le $max_attempts ]; do
              if [ "$(docker inspect --format='{{.State.Health.Status}}' $container_name 2>/dev/null)" = "healthy" ]; then
                echo "âœ… $container_name is healthy"
                return 0
              fi
              
              echo "ðŸ”„ Attempt $attempt/$max_attempts: Waiting for $container_name to be healthy..."
              sleep 10
              ((attempt++))
            done
            
            echo "âŒ $container_name failed health check"
            return 1
          }

          # Function to rollback
          rollback() {
            echo "ðŸ”„ Rolling back to previous version..."
            
            if docker ps -a | grep -q $BACKUP_CONTAINER; then
              echo "ðŸ“¦ Stopping current container..."
              docker stop $APP_CONTAINER || true
              docker rm $APP_CONTAINER || true
              
              echo "ðŸ”„ Starting backup container..."
              docker start $BACKUP_CONTAINER
              docker rename $BACKUP_CONTAINER $APP_CONTAINER
              
              echo "âœ… Rollback completed"
            else
              echo "âŒ No backup container found for rollback"
              exit 1
            fi
          }

          # Stop and remove any existing containers
          echo "ðŸ§¹ Cleaning up existing containers..."
          
          # Force stop and remove any containers using our ports
          echo "ðŸ” Checking for processes using ports 3001 and 5432..."
          
          # Function to kill processes on a port
          kill_port_processes() {
            local port=$1
            
            # Try lsof first
            if command -v lsof >/dev/null 2>&1; then
              PROCESS=$(lsof -ti :$port 2>/dev/null || true)
              if [ ! -z "$PROCESS" ]; then
                echo "âš ï¸ Killing process using port $port: $PROCESS"
                kill -9 $PROCESS 2>/dev/null || true
                sleep 2
              fi
            fi
            
            # Try netstat + kill as fallback
            if command -v netstat >/dev/null 2>&1; then
              PROCESS=$(netstat -tlnp 2>/dev/null | grep ":$port " | awk '{print $7}' | cut -d'/' -f1 | grep -v '^-$' || true)
              if [ ! -z "$PROCESS" ]; then
                echo "âš ï¸ Killing process using port $port (netstat): $PROCESS"
                kill -9 $PROCESS 2>/dev/null || true
                sleep 2
              fi
            fi
            
            # Try ss + kill as another fallback
            if command -v ss >/dev/null 2>&1; then
              PROCESS=$(ss -tlnp 2>/dev/null | grep ":$port " | sed 's/.*pid=\([0-9]*\).*/\1/' | head -1 || true)
              if [ ! -z "$PROCESS" ] && [ "$PROCESS" != "$(ss -tlnp 2>/dev/null | grep ":$port " | head -1)" ]; then
                echo "âš ï¸ Killing process using port $port (ss): $PROCESS"
                kill -9 $PROCESS 2>/dev/null || true
                sleep 2
              fi
            fi
          }
          
          # Kill processes using our ports
          kill_port_processes 3001
          kill_port_processes 5432
          
          # Force stop and remove ALL containers with our names (including any orphaned ones)
          echo "ðŸ§¹ Force stopping and removing containers by name..."
          docker stop $APP_CONTAINER $DB_CONTAINER 2>/dev/null || true
          docker rm -f $APP_CONTAINER $DB_CONTAINER 2>/dev/null || true
          docker rm -f $BACKUP_CONTAINER 2>/dev/null || true
          
          # Also clean up any containers that might be using our image
          echo "ðŸ§¹ Removing containers using our image..."
          docker ps -a --filter "ancestor=${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest" -q | xargs -r docker rm -f
          
          # Stop and remove any compose stack
          echo "ðŸ›‘ Stopping any existing compose stack..."
          $DOCKER_COMPOSE_CMD -f $COMPOSE_FILE down --remove-orphans --volumes 2>/dev/null || true
          
          # Remove any existing networks and volumes 
          echo "ðŸ§¹ Cleaning up networks and volumes..."
          docker network rm x-fleet-deployment_xfleet 2>/dev/null || true
          docker volume rm x-fleet-deployment_postgres_data 2>/dev/null || true
          
          # Wait for ports to be fully released
          echo "â³ Waiting for ports to be released..."
          sleep 5
          
          # Function to check if port is available
          check_port_available() {
            local port=$1
            
            # Try lsof first
            if command -v lsof >/dev/null 2>&1; then
              if lsof -ti :$port >/dev/null 2>&1; then
                return 1  # Port is in use
              fi
            fi
            
            # Try netstat as fallback
            if command -v netstat >/dev/null 2>&1; then
              if netstat -tln 2>/dev/null | grep -q ":$port "; then
                return 1  # Port is in use
              fi
            fi
            
            # Try ss as another fallback
            if command -v ss >/dev/null 2>&1; then
              if ss -tln 2>/dev/null | grep -q ":$port "; then
                return 1  # Port is in use
              fi
            fi
            
            return 0  # Port is available
          }
          
          # Verify ports are now available
          for port in 3001 5432; do
            if ! check_port_available $port; then
              echo "âŒ Port $port is still in use after cleanup!"
              
              # Show what's using the port for debugging
              if command -v lsof >/dev/null 2>&1; then
                lsof -i :$port 2>/dev/null || true
              elif command -v netstat >/dev/null 2>&1; then
                netstat -tlnp 2>/dev/null | grep ":$port " || true
              elif command -v ss >/dev/null 2>&1; then
                ss -tlnp 2>/dev/null | grep ":$port " || true
              fi
              
              echo "âŒ Cannot proceed with deployment - port conflict!"
              exit 1
            else
              echo "âœ… Port $port is available"
            fi
          done
          
          # Pull latest images
          echo "ðŸ“¥ Pulling latest images..."
          docker pull ${{ secrets.REGISTRY_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          docker pull postgres:15-alpine

          # Start all containers with docker-compose
          echo "ðŸš€ Starting all containers..."
          $DOCKER_COMPOSE_CMD -f $COMPOSE_FILE up -d
          
          # Wait for database to be healthy first
          echo "â³ Waiting for database to be ready..."
          if ! check_health $DB_CONTAINER; then
            echo "âŒ Database health check failed"
            rollback
            exit 1
          fi
          
          # Then wait for application to be healthy
          echo "â³ Waiting for application to be ready..."

          # Check if deployment was successful
          if check_health $APP_CONTAINER; then
            echo "âœ… Deployment successful!"
            
            # Remove backup container if deployment succeeded
            if docker ps -a | grep -q $BACKUP_CONTAINER; then
              echo "ðŸ§¹ Removing backup container..."
              docker rm $BACKUP_CONTAINER || true
            fi
            
            # Clean up unused images
            docker image prune -f
            
            echo "ðŸŽ‰ X-Fleet deployment completed successfully!"
          else
            echo "âŒ Deployment failed!"
            rollback
            exit 1
          fi
          EOF

          chmod +x deploy/deploy.sh
          
          # Debug: Show generated files
          echo "=== Generated docker-compose.prod.yml ==="
          cat deploy/docker-compose.prod.yml
          echo "=== End of docker-compose.prod.yml ==="

      - name: ðŸ“¤ Deploy to EC2 Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          timeout: 300s
          command_timeout: 60s
          script: |
            # Create deployment directory
            mkdir -p ~/x-fleet-deployment
            cd ~/x-fleet-deployment
            
            # Install Docker if not present
            if ! command -v docker &> /dev/null; then
              echo "ðŸ³ Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              newgrp docker
            fi
            
            # Install Docker Compose if not present
            if ! docker compose version &> /dev/null && ! docker-compose version &> /dev/null; then
              echo "ðŸ™ Installing Docker Compose..."
              sudo apt-get update
              sudo apt-get install -y docker-compose-plugin
              
              # Fallback: install standalone docker-compose if plugin fails
              if ! docker compose version &> /dev/null; then
                echo "ðŸ”„ Installing standalone docker-compose..."
                sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                sudo chmod +x /usr/local/bin/docker-compose
              fi
            else
              echo "âœ… Docker Compose already installed"
              docker compose version 2>/dev/null || docker-compose version
            fi
            
            # Login to Docker registry
            echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ secrets.REGISTRY_URL }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
            
            echo "ðŸš€ Starting deployment process..."

      - name: ðŸ“ Copy Deployment Files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          source: "deploy/*"
          target: "~/x-fleet-deployment/"
          strip_components: 1

      - name: ðŸš€ Execute Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          timeout: 600s
          script: |
            cd ~/x-fleet-deployment
            
            # Check if .env file exists, create if not
            if [ ! -f .env ]; then
              echo "ðŸ“ Creating .env file from environment variables..."
              cat > .env << 'EOF'
            # Environment Configuration for FleetStack Backend
            NODE_ENV=production
            PORT=3001

            # Database Configuration
            POSTGRES_USER=postgres
            POSTGRES_PASSWORD=Stack@321
            POSTGRES_DB=postgres

            # Primary Database Configuration (FleetStack_db)
            PRIMARY_DB_HOST=x-fleet-postgres
            PRIMARY_DB_USER=postgres
            PRIMARY_DB_PORT=5432
            PRIMARY_DB_PASSWORD=Stack@321
            PRIMARY_DB_NAME=FleetStack_db
            PRIMARY_DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_db?schema=public"

            # Logs Database Configuration (FleetStack_logs)
            LOGS_DB_HOST=x-fleet-postgres
            LOGS_DB_USER=postgres
            LOGS_DB_PORT=5432
            LOGS_DB_PASSWORD=Stack@321
            LOGS_DB_NAME=FleetStack_logs
            LOGS_DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_logs?schema=public"

            # Address Database Configuration (FleetStack_Address)
            ADDRESS_DB_HOST=x-fleet-postgres
            ADDRESS_DB_USER=postgres
            ADDRESS_DB_PORT=5432
            ADDRESS_DB_PASSWORD=Stack@321
            ADDRESS_DB_NAME=FleetStack_Address
            ADDRESS_DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_Address?schema=public"

            # Default DATABASE_URL for Prisma
            DATABASE_URL="postgresql://postgres:Stack@321@x-fleet-postgres:5432/FleetStack_db?schema=public"
            EOF
            fi
            
            # Make deployment script executable and run it
            chmod +x deploy.sh
            ./deploy.sh

  # Notification Job
  notify:
    name: ðŸ“¢ Notify
    needs: [build, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: ðŸ“Š Deployment Status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "âœ… Deployment succeeded!"
            echo "ðŸŒ Application URL: http://${{ secrets.EC2_HOST }}:3001"
            echo "ðŸ—„ï¸ Database URL: ${{ secrets.EC2_HOST }}:5432"
          elif [[ "${{ needs.deploy.result }}" == "failure" ]]; then
            echo "âŒ Deployment failed!"
            exit 1
          elif [[ "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "â­ï¸ Deployment skipped (not main branch)"
          fi
